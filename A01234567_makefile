# makefile for hello world
# coded by Carol Hazlewood
# September 9, 2008
# modified by Preston Maness
# 7 June 2012

# I can't agree with manually editing makefiles when the autotools
# do a far superior job of it. And of course you don't want to pull
# a Bumblebee. Deleting /usr will NOT speed up your computer...

# ===========================================================

#letting make work for us...

CXX=g++
AS=as
CXXFLAGS=-c -g -Wall -O3
LDFLAGS=
SOURCES=A01234567_hello.cpp
PP=$(SOURCES:.cpp=.i)
ASM=$(SOURCES:.cpp=.s)
OBJECTS=$(SOURCES:.cpp=.o)
EXECUTABLE=A01234567_hello

# ===========================================================

# The typical case. Preprocessing and compiling and assembling,
# then linking to make an executable. 

output: $(EXECUTABLE)
	./$(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS)
	$(CXX) $(LDFLAGS) $(OBJECTS) -o $@

.cpp.o:
	$(CXX) $(CXXFLAGS) $< -o $@

# ===========================================================

# the following rules produce intermediate files
# and demonstrate the build process step by step

# In short, you have:
# input.cpp -> preprocessed.i -> compiled.s -> assembled.o -> linked executable

# Preprocessor: Invoked with `g++` and -E flag. Expands all macros
		and includes and gives preprocessed output (.i files)

# Compiler: Invoked with `g++` and all CXXFLAGS, and takes the 
# 		preprocessed input (.i files). However, use -S flag
# 		to stop at compiling and give the assembler output (.s files).

# Assembler: Invoked with `as`, takes the assembler files (.s files)
		 and outputs object code (.o files).

# Linker: Technically invoked by `ld` but that's complicated
# 		so use `g++` and any LDFLAGS you need that takes the 
# 		object files (.o files) and spits out a linked executable.          
#		Typically the executable does not have an extension.

# ===========================================================

# preprocessed produces source file with include statements expanded

# it redirects the output to file A01234567_hello.i

A01234567_preprocessed: $(SOURCES)
	$(CXX) -E $(SOURCES) > $(PP)

# ===========================================================

# compiled produces assembly language file A01234567_hello.s

# it takes the preprocessed file and spits out assembler (.s files)

A01234567_compiled: $(PP)
	$(CXX) $(CXXFLAGS) -S $(PP) -o $(ASM)

# ===========================================================

# assembled produces object language file A01234567_hello.o
# and hexdump's it to a file A01234567_o_dump

# in this case, we call the assembler directly and it takes
# the .s files and spits out .o files (object files).

A01234567_assembled: $(ASM)
	$(AS) $(ASM) -o $(OBJECTS) && hexdump $(OBJECTS) > A01234567_o_dump 

# ===========================================================

# linked produces executable language file A01234567_hello
# and hexdump's it to a file A01234567_x_dump

# At this point we link together all of the object files and
# and make the executable. G++ technically calls `ld` to do
# the linking. We don't use ld ourselves because we don't
# hate ourselves.

A01234567_linked: $(OBJECTS)
	$(CXX) $(LDFLAGS) $(OBJECTS) -o $(EXECUTABLE) && hexdump $(EXECUTABLE) > A01234567_x_dump 

# ===========================================================

clean:
	rm -f *.o
	rm -f *.s
	rm -f A01234567_hello
	rm -f *dump*
	rm -f *preproc*